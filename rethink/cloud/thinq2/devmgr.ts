// This class handles the devices connecting to the internal MQTT broker. This includes both device provisioning
// and minimal wrappers for actual data exchange. The device class is responsible for generating/parsing the payload.

import { generateDeployResponse } from './provisioning.js'
import { TypedEmitter } from 'tiny-typed-emitter';
import { Client, PublishPacket, type Broker } from '../mqtt-broker.js'
import { ClipDeployMessage } from './clip.js'

import log from '../../util/logging.js'
import { Metadata } from '../thinq.js'

type DeviceEvents = {
    data: (packet: Buffer) => void;
    close: () => void;
}

export class Device extends TypedEmitter<DeviceEvents> {
	// this could be a stream but why bother...
	constructor(readonly broker: Broker, readonly topic: string, readonly id: string) {
		super()
	}

	send(buf: Buffer) {
		const messagestr = JSON.stringify({"did": this.id,"mid":Date.now(),"cmd":"packet","type":1,"data":Buffer.from(buf).toString("hex")})
		this.broker.publish({topic: this.topic, retain: false, qos: 0, dup: false, payload: messagestr}, null /* message generated by the broker itself */)
	}
}

function trimNull(buf: Buffer) {
	if(!buf || !buf.length || buf[buf.length-1])
		return buf
	return buf.subarray(0, buf.length-1)
}

type ClientWithExtra = Client & {
	deviceObj: undefined | Device
	deployMsg: undefined | ClipDeployMessage
}

type DeviceManagerEvents = {
	newDevice: (dev: Device, meta: Metadata) => void;
}

export class DeviceManager extends TypedEmitter<DeviceManagerEvents> {
	clientsById: Record<string, Client> = {}
	constructor(readonly broker: Broker) {
		super()

		broker.on('publish', (packet, client) => {
			log('incoming', packet.topic, packet.payload.toString('utf-8'))

			if(!client)
				return;

			try {
				if(packet.topic.indexOf('clip/') >= 0) {
					const payload = JSON.parse(trimNull(Buffer.from(packet.payload)).toString('utf-8'))
					this.mqtt(packet.topic, payload, client as ClientWithExtra)
				}
			} catch(err) {
				console.warn(err, packet.payload.toString('hex'))
			}
		})
					
		broker.on('disconnect', this.disconnected.bind(this))
	}

	mqtt(topic: string, payload, client: ClientWithExtra) {
		// experiment: try to support devices which use other topic formats
		topic = topic.replace(/^.*\/clip/, "clip")

		if(topic === 'clip/message/devices/' + payload.did) {
			if(payload.cmd === 'completeProvisioning_ack') {
				this.completeProvisioning(payload.did, payload, client)
			}

			if(payload.cmd === 'device_packet' && client.deviceObj && payload.did === client.deviceObj.id) {
				const buf = Buffer.from(payload.data, 'hex')
				client.deviceObj.emit('data', buf)
			}
		}
	
		if(topic === 'clip/provisioning/devices/' + payload.did) {
			if(payload.cmd === 'preDeploy' || payload.cmd === 'deploy') {
				client.deployMsg = payload
				this.broker.publish({
						topic: 'lime/devices/' + payload.did,
						retain: false,
						qos: 0,
						dup: false,
						payload: JSON.stringify(generateDeployResponse(payload))}, null)
			}
		}
	}

	completeProvisioning(deviceId: string, payload, client: ClientWithExtra) {
		if(!client.deployMsg) {
			console.warn("completeProvisioning_ack received without deploy/preDeploy")
			return
		}

		if(client.deviceObj) {
			console.warn("completeProvisioning_ack received twice?")
			return
		}
		
		if(this.clientsById[deviceId]) {
			console.warn(`device ${deviceId} already connected, dropping the old one`)
			this.clientsById[deviceId].destroy()
		}

		this.clientsById[deviceId] = client
		
		const dev = new Device(this.broker, 'lime/devices/' + deviceId, deviceId)
		client.deviceObj = dev

		const meta: Metadata = {
			modelId: client.deployMsg.kind,
			modelName: client.deployMsg.data?.appInfo?.modelName,
			swVersion: client.deployMsg.data?.appInfo?.softVer
		}
		this.emit('newDevice', dev, meta)
	}

	disconnected(client) {
		if(client.deviceObj) {
			delete this.clientsById[client.deviceObj.id]
			client.deviceObj.emit('close')
			client.deviceObj = null
		}
	}
}